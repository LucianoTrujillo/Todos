{"ast":null,"code":"var _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nimport parseDate from './parseDate';\nvar namespaces = {\n  a: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main' // Maps \"A1\"-like coordinates to `{ row, column }` numeric coordinates.\n\n};\nvar letters = [\"\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"];\n/**\r\n * Reads an (unzipped) XLSX file structure into a 2D array of cells.\r\n * @param  {object} contents - A list of XML files inside XLSX file (which is a zipped directory).\r\n * @param  {number?} options.sheet - Workbook sheet id (`1` by default).\r\n * @param  {string?} options.dateFormat - Date format, e.g. \"MM/DD/YY\". Values having this format template set will be parsed as dates.\r\n * @param  {object} contents - A list of XML files inside XLSX file (which is a zipped directory).\r\n * @return {object} An object of shape `{ data, cells, properties }`. `data: string[][]` is an array of rows, each row being an array of cell values. `cells: string[][]` is an array of rows, each row being an array of cells. `properties: object` is the spreadsheet properties (e.g. whether date epoch is 1904 instead of 1900).\r\n */\n\nexport default function readXlsx(contents, xml) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {}; // Deprecated 1.0.0 `sheet` argument. Will be removed in some next major release.\n\n  if (typeof options === 'string' || typeof options === 'number') {\n    options = {\n      sheet: options\n    };\n  } else if (!options.sheet) {\n    options = _extends({}, options, {\n      sheet: 1\n    });\n  }\n\n  var sheet = void 0;\n  var properties = void 0; // Error which will not be skipped.\n\n  var criticalError = void 0;\n\n  try {\n    var values = parseValues(contents['xl/sharedStrings.xml'], xml);\n    var styles = parseStyles(contents['xl/styles.xml'], xml);\n\n    var _properties = parseProperties(contents['xl/workbook.xml'], xml); // A hack for `getSheets()` method.\n    // https://github.com/catamphetamine/read-excel-file/issues/14\n\n\n    if (options.getSheets) {\n      return _properties.sheets;\n    } // Parse sheet data.\n\n\n    var sheetId = typeof options.sheet === 'number' ? options.sheet : getSheetId(_properties.sheets, options.sheet);\n\n    if (!sheetId || !contents['xl/worksheets/sheet' + sheetId + '.xml']) {\n      criticalError = createSheetNotFoundError(options.sheet, _properties.sheets);\n      throw criticalError;\n    }\n\n    sheet = parseSheet(contents['xl/worksheets/sheet' + sheetId + '.xml'], xml, values, styles, _properties, options);\n  } catch (error) {\n    if (error === criticalError) {\n      throw error;\n    } // Guards against malformed XLSX files.\n    // Actually perhaps remove this in some next major version.\n    // So marking this `catch` \"Deprecated\".\n\n\n    console.error(error); // A hack for `getSheets()` method.\n    // https://github.com/catamphetamine/read-excel-file/issues/14\n\n    if (options.getSheets) {\n      return {};\n    } // Return sheet data.\n\n\n    if (options.schema) {\n      return {\n        data: [],\n        properties: {}\n      };\n    }\n\n    return [];\n  }\n\n  var _sheet$dimensions = _slicedToArray(sheet.dimensions, 2),\n      leftTop = _sheet$dimensions[0],\n      rightBottom = _sheet$dimensions[1];\n\n  var cols = rightBottom.column - leftTop.column + 1;\n  var rows = rightBottom.row - leftTop.row + 1;\n  var cells = [];\n  times(rows, function () {\n    var row = [];\n    times(cols, function () {\n      return row.push({\n        value: null\n      });\n    });\n    cells.push(row);\n  });\n\n  for (var _iterator = sheet.cells, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var cell = _ref;\n    var row = cell.row - leftTop.row;\n    var column = cell.column - leftTop.column;\n\n    if (cells[row]) {\n      cells[row][column] = cell;\n    }\n  }\n\n  var data = cells.map(function (row) {\n    return row.map(function (cell) {\n      return cell.value;\n    });\n  });\n  data = dropEmptyRows(dropEmptyColumns(data), options.rowMap); // cells = dropEmptyRows(dropEmptyColumns(cells, _ => _.value), options.rowMap, _ => _.value)\n\n  if (options.schema) {\n    return {\n      data: data,\n      properties: properties\n    };\n  }\n\n  return data;\n}\n\nfunction calculateDimensions(cells) {\n  var comparator = function comparator(a, b) {\n    return a - b;\n  };\n\n  var allRows = cells.map(function (cell) {\n    return cell.row;\n  }).sort(comparator);\n  var allCols = cells.map(function (cell) {\n    return cell.column;\n  }).sort(comparator);\n  var minRow = allRows[0];\n  var maxRow = allRows[allRows.length - 1];\n  var minCol = allCols[0];\n  var maxCol = allCols[allCols.length - 1];\n  return [{\n    row: minRow,\n    column: minCol\n  }, {\n    row: maxRow,\n    column: maxCol\n  }];\n}\n\nfunction times(n, action) {\n  var i = 0;\n\n  while (i < n) {\n    action();\n    i++;\n  }\n}\n\nfunction colToInt(col) {\n  col = col.trim().split('');\n  var n = 0;\n\n  for (var i = 0; i < col.length; i++) {\n    n *= 26;\n    n += letters.indexOf(col[i]);\n  }\n\n  return n;\n}\n\nfunction CellCoords(coords) {\n  coords = coords.split(/(\\d+)/);\n  return {\n    row: parseInt(coords[1]),\n    column: colToInt(coords[0])\n  };\n}\n\nfunction Cell(cellNode, sheet, xml, values, styles, properties, options) {\n  var coords = CellCoords(cellNode.getAttribute('r'));\n  var value = xml.select(sheet, cellNode, 'a:v', namespaces)[0]; // For `xpath` `value` can be `undefined` while for native `DOMParser` it's `null`.\n\n  value = value && value.textContent; // http://webapp.docx4java.org/OnlineDemo/ecma376/SpreadsheetML/ST_CellType.html\n\n  switch (cellNode.getAttribute('t')) {\n    case 's':\n      value = values[parseInt(value)].trim();\n\n      if (value === '') {\n        value = undefined;\n      }\n\n      break;\n\n    case 'b':\n      value = value === '1' ? true : false;\n      break;\n\n    case 'n': // Default type is \"n\".\n    // http://www.datypic.com/sc/ooxml/t-ssml_CT_Cell.html\n\n    default:\n      if (value === undefined) {\n        break;\n      }\n\n      value = parseFloat(value); // XLSX has no specific format for dates.\n      // Sometimes a date can be heuristically detected.\n      // https://github.com/catamphetamine/read-excel-file/issues/3#issuecomment-395770777\n\n      var style = styles[parseInt(cellNode.getAttribute('s') || 0)];\n\n      if (style.numberFormat.id >= 14 && style.numberFormat.id <= 22 || style.numberFormat.id >= 45 && style.numberFormat.id <= 47 || options.dateFormat && style.numberFormat.template === options.dateFormat || options.smartDateParser !== false && style.numberFormat.template && isDateTemplate(style.numberFormat.template)) {\n        value = parseDate(value, properties);\n      }\n\n      break;\n  } // Convert empty values to `null`.\n\n\n  if (value === undefined) {\n    value = null;\n  }\n\n  return {\n    row: coords.row,\n    column: coords.column,\n    value: value\n  };\n}\n\nexport function dropEmptyRows(data, rowMap) {\n  var accessor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (_) {\n    return _;\n  }; // Fill in row map.\n\n  if (rowMap) {\n    var j = 0;\n\n    while (j < data.length) {\n      rowMap[j] = j;\n      j++;\n    }\n  } // Drop empty rows.\n\n\n  var i = data.length - 1;\n\n  while (i >= 0) {\n    // Check if the row is empty.\n    var empty = true;\n\n    for (var _iterator2 = data[i], _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var cell = _ref2;\n\n      if (accessor(cell) !== null) {\n        empty = false;\n        break;\n      }\n    } // Remove the empty row.\n\n\n    if (empty) {\n      data.splice(i, 1);\n\n      if (rowMap) {\n        rowMap.splice(i, 1);\n      }\n    }\n\n    i--;\n  }\n\n  return data;\n}\nexport function dropEmptyColumns(data) {\n  var accessor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (_) {\n    return _;\n  };\n  var i = data[0].length - 1;\n\n  while (i >= 0) {\n    var empty = true;\n\n    for (var _iterator3 = data, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n      var _ref3;\n\n      if (_isArray3) {\n        if (_i3 >= _iterator3.length) break;\n        _ref3 = _iterator3[_i3++];\n      } else {\n        _i3 = _iterator3.next();\n        if (_i3.done) break;\n        _ref3 = _i3.value;\n      }\n\n      var row = _ref3;\n\n      if (accessor(row[i]) !== null) {\n        empty = false;\n        break;\n      }\n    }\n\n    if (empty) {\n      var j = 0;\n\n      while (j < data.length) {\n        data[j].splice(i, 1);\n        j++;\n      }\n    }\n\n    i--;\n  }\n\n  return data;\n}\n\nfunction parseSheet(content, xml, values, styles, properties, options) {\n  var sheet = xml.createDocument(content);\n  var cells = xml.select(sheet, null, '/a:worksheet/a:sheetData/a:row/a:c', namespaces).map(function (node) {\n    return Cell(node, sheet, xml, values, styles, properties, options);\n  });\n  var dimensions = xml.select(sheet, null, '//a:dimension/@ref', namespaces)[0];\n\n  if (dimensions) {\n    dimensions = dimensions.textContent.split(':').map(CellCoords); // When there's only a single cell on a sheet\n    // there can sometimes be just \"A1\" for the dimensions string.\n\n    if (dimensions.length === 1) {\n      dimensions = [dimensions[0], dimensions[0]];\n    }\n  } else {\n    dimensions = calculateDimensions(cells);\n  }\n\n  return {\n    cells: cells,\n    dimensions: dimensions\n  };\n}\n\nfunction parseValues(content, xml) {\n  var strings = xml.createDocument(content);\n  return xml.select(strings, null, '//a:si', namespaces).map(function (string) {\n    return xml.select(strings, string, './/a:t[not(ancestor::a:rPh)]', namespaces).map(function (_) {\n      return _.textContent;\n    }).join('');\n  });\n} // http://officeopenxml.com/SSstyles.php\n\n\nfunction parseStyles(content, xml) {\n  if (!content) {\n    return {};\n  } // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/708978af-b598-45c4-a598-d3518a5a09f0/howwhen-is-cellstylexfs-vs-cellxfs-applied-to-a-cell?forum=os_binaryfile\n  // https://www.office-forums.com/threads/cellxfs-cellstylexfs.2163519/\n\n\n  var doc = xml.createDocument(content);\n  var baseStyles = xml.select(doc, null, '//a:styleSheet/a:cellStyleXfs/a:xf', namespaces).map(parseCellStyle);\n  var numFmts = xml.select(doc, null, '//a:styleSheet/a:numFmts/a:numFmt', namespaces).map(parseNumberFormatStyle).reduce(function (formats, format) {\n    formats[format.id] = format;\n    return formats;\n  }, []);\n  return xml.select(doc, null, '//a:styleSheet/a:cellXfs/a:xf', namespaces).map(function (xf) {\n    if (xf.hasAttribute('xfId')) {\n      return _extends({}, baseStyles[xf.xfId], parseCellStyle(xf, numFmts));\n    }\n\n    return parseCellStyle(xf, numFmts);\n  });\n}\n\nfunction parseNumberFormatStyle(numFmt) {\n  return {\n    id: numFmt.getAttribute('numFmtId'),\n    template: numFmt.getAttribute('formatCode')\n  };\n} // http://www.datypic.com/sc/ooxml/e-ssml_xf-2.html\n\n\nfunction parseCellStyle(xf, numFmts) {\n  var style = {};\n\n  if (xf.hasAttribute('numFmtId')) {\n    var numberFormatId = xf.getAttribute('numFmtId');\n\n    if (numFmts[numberFormatId]) {\n      style.numberFormat = numFmts[numberFormatId];\n    } else {\n      style.numberFormat = {\n        id: numberFormatId\n      };\n    }\n  }\n\n  return style;\n}\n\nfunction parseProperties(content, xml) {\n  if (!content) {\n    return {};\n  }\n\n  var book = xml.createDocument(content); // http://webapp.docx4java.org/OnlineDemo/ecma376/SpreadsheetML/workbookPr.html\n\n  var workbookProperties = xml.select(book, null, '//a:workbookPr', namespaces)[0];\n\n  if (!workbookProperties) {\n    return {};\n  }\n\n  var properties = {}; // https://support.microsoft.com/en-gb/help/214330/differences-between-the-1900-and-the-1904-date-system-in-excel\n\n  if (workbookProperties.getAttribute('date1904') === '1') {\n    properties.epoch1904 = true;\n  } // Get sheet names (just because they're available).\n\n\n  for (var _iterator4 = xml.select(book, null, '//a:sheets/a:sheet', namespaces), _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {\n    var _ref4;\n\n    if (_isArray4) {\n      if (_i4 >= _iterator4.length) break;\n      _ref4 = _iterator4[_i4++];\n    } else {\n      _i4 = _iterator4.next();\n      if (_i4.done) break;\n      _ref4 = _i4.value;\n    }\n\n    var sheet = _ref4;\n\n    if (sheet.getAttribute('name')) {\n      properties.sheets = properties.sheets || {};\n      properties.sheets[sheet.getAttribute('sheetId')] = sheet.getAttribute('name');\n    }\n  }\n\n  return properties;\n}\n\nfunction isDateTemplate(template) {\n  var tokens = template.split(/\\W+/);\n\n  for (var _iterator5 = tokens, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {\n    var _ref5;\n\n    if (_isArray5) {\n      if (_i5 >= _iterator5.length) break;\n      _ref5 = _iterator5[_i5++];\n    } else {\n      _i5 = _iterator5.next();\n      if (_i5.done) break;\n      _ref5 = _i5.value;\n    }\n\n    var token = _ref5;\n\n    if (['MM', 'DD', 'YY', 'YYYY'].indexOf(token) < 0) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction getSheetId(sheets, name) {\n  if (!sheets) {\n    return;\n  }\n\n  for (var _iterator6 = Object.keys(sheets), _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {\n    var _ref6;\n\n    if (_isArray6) {\n      if (_i6 >= _iterator6.length) break;\n      _ref6 = _iterator6[_i6++];\n    } else {\n      _i6 = _iterator6.next();\n      if (_i6.done) break;\n      _ref6 = _i6.value;\n    }\n\n    var sheetId = _ref6;\n\n    if (sheets[sheetId] === name) {\n      return sheetId;\n    }\n  } // Deprecated.\n  // Legacy support for `sheet: '1'`, etc.\n\n\n  var id = parseInt(name, 10);\n\n  if (String(id) === name) {\n    return id;\n  }\n}\n\nfunction createSheetNotFoundError(sheet, sheets) {\n  var sheetNames = {};\n\n  if (sheets) {\n    sheetNames = Object.keys(sheets).filter(function (id) {\n      return sheets[id];\n    }).reduce(function (names, id) {\n      names[id] = sheets[id];\n      return names;\n    }, {});\n  }\n\n  var sheetNamesText = Object.keys(sheetNames).map(function (id) {\n    return '\"' + sheetNames[id] + '\" (#' + id + ')';\n  }).join(', ');\n  return new Error('Sheet ' + (typeof sheet === 'number' ? '#' + sheet : '\"' + sheet + '\"') + ' not found in *.xlsx file.' + (sheetNamesText ? ' Available sheets: ' + sheetNamesText + '.' : ''));\n}","map":null,"metadata":{},"sourceType":"module"}